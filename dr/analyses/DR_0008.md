# DR_0008

- span: L7863-L8917
- sha256: 66eda2cbf034c43e3a0230037a28327c02b5b3d43ed5bd67ca9a398d17db4f38
- tags: onramp, security, integration, testing, compliance, ui
- importance: M

## Что утверждается
### Primary findings
> # Целевая архитектура Telegram on-ramp бота (To-Be)
> 
> ## PlantUML схема архитектуры
> 
> ```plantuml
> @startuml
> skinparam componentStyle rectangle
> skinparam packageStyle rectangle
> 
> package "App Layer (Application)" {
>   component "Telegram Bot" as Bot
>   component "FSM Manager" as FSM
>   component "Localization & UI" as UI
> }
> 
> package "Domain Layer (Core Logic)" {
>   component "Aggregator Selector" as Selector
>   component "Aggregator Scoring & Decline Index" as Scoring
>   component "Deeplink Generator" as Deeplink
>   component "Strategy Registry" as Registry
>   component "Fail-Closed Guard" as FailGuard
> }
> 
> package "Data Layer (Configs)" {
>   component "Aggregators Config (YAML)" as AggConfig
>   component "Weights Scheme (YAML)" as WeightConfig
>   component "Dynamic Limits Store" as LimitsStore
>   component "Config Schema Validators" as Validators
> }
> 
> package "Infrastructure Layer" {
>   component "Telegram Bot API" as TelegramAPI
>   component "FSM State Storage (e.g. Redis)" as StateStore
>   component "CI/CD Pipeline" as CICD
>   component "Monitoring & Logging" as Monitoring
> }
> 
> Bot --> TelegramAPI : взаимодействие
> Bot --> FSM : управление состояниями
> Bot --> UI : сценарии диалогов (мультиязычные)
> FSM --> StateStore : сохранение состояний
> Bot --> Selector : запрос лучшего агрегатора
> Selector --> Scoring : расчет рейтингов агрегаторов
> Selector --> Registry : список доступных стратегий
> Scoring --> LimitsStore : учитывает динамические лимиты
> Scoring --> WeightConfig : применяет весовые коэффициенты
> Scoring --> FailGuard : проверка условий (fail-closed)
> Selector --> Deeplink : генерация deeplink URL
> Deeplink --> AggConfig : шаблоны ссылок и параметры
> AggConfig --> Validators : валидация схем конфигурации
> CICD -> Bot : деплой при успешных тестах
> Monitoring .. Bot : отслеживание ошибок и событий
> @enduml
> ```
> 
> ## Описание ключевых компонентов
> 
> Архитектура бота разделена на четыре слоя: **Application (App)**, **Domain**, **Data**, и **Infrastructure**. Такой многоуровневый дизайн обеспечивает модульность, упрощает поддержку и масштабирование, а также отражает рекомендации предыдущих этапов (Mod1/2/3) и результаты исследований (Res1/2) по лучшим практикам (MoonPay, Ramp и др.).
> 
> ### Слой Application (App)
> 
> **Telegram Bot** – верхний уровень приложения, отвечающий за взаимодействие с пользователем через Telegram. Он обрабатывает входящие сообщения и команды, реагируя согласно заложенным сценариям. Логика диалогов реализована как конечный автомат состояний (FSM), что было рекомендовано в Mod1 для управления сложными пользовательскими сценариями. Использование FSM позволяет организовать поэтапное взаимодействие – пользователь последовательно проходит шаги (например, выбор суммы, агрегатора и т.д.) с сохранением контекста между сообщениями【38†L475-L483】. Такой подход гарантирует, что многошаговые процессы (например, ввод данных для покупки) не собьются и данные каждого шага правильно обрабатываются.
> 
> **FSM Manager** – компонент, управляющий состояниями и переходами сценария. На каждом шаге бот находится в определённом состоянии и ждёт определённого ввода. После получения корректного ввода FSM переводит бот в следующее состояние или завершает сценарий. Благодаря этому реализованы **UI-сценарии** – предопределённые последовательности сообщений и вопросов. Например, сценарий покупки может включать состояния: выбор валюты, ввод суммы, подтверждение и получение ссылки. Данный подход соответствует лучшим практикам разработки ботов: FSM считается ключевым инструментом для многошаговых диалогов【38†L475-L483】, как и предлагалось в Mod2.
> 
> **Localization & UI** – подсистема локализации и формирования сообщений. Бот поддерживает **мультиязычность**, т.е. интерфейс на нескольких языках (например, русский, английский и др.), как было отмечено в Mod1 для глобального охвата аудитории. Все текстовые сообщения, кнопки и ошибки хранятся в виде шаблонов с переводами. При взаимодействии бот автоматически выбирает язык (например, на основе настроек пользователя Telegram или команды выбора языка). Такой подход соответствует практике ведущих on-ramp сервисов: например, MoonPay предоставляет интерфейс на множестве языков для охвата 180+ стран【32†L315-L323】. Локализация реализована через файл ресурсов или словарь, что облегчает добавление новых языков.
> 
> **Friendly Error Handling** – система дружелюбных ошибок. Все ошибки, возникающие в ходе работы бота, перехватываются и обрабатываются в App-слое. Вместо отображения технических деталей пользователю показываются понятные сообщения (также переведённые на язык пользователя). Например, если ни один агрегатор не доступен, бот вернёт сообщение вроде «К сожалению, сейчас нет доступных предложений. Попробуйте позже.» Вместе с тем ошибки логируются для разработчиков. Такой механизм был предложен в Mod1/Mod3 для повышения UX и доверия пользователей. Он частично компенсирует отсутствие прямой поддержки, характерное для агрегаторов: известно, что агрегаторы зачастую не предоставляют полноценную поддержку и ограничиваются FAQ, что не решает проблемы пользователя【36†L171-L174】. В нашем решении бот старается максимально проинформировать пользователя о проблеме и дальнейших шагах (например, предложит попробовать меньшую сумму или позже), тем самым улучшая опыт взаимодействия.
> 
> Кроме того, Application-слой реализует **fail-closed guards** на уровне интерфейса: если на каком-то шаге происходят непредвиденные ситуации (например, невалидные данные или сбой логики), бот безопасно прерывает сценарий. По принципу _“fail-closed”_, в случае сбоя диалог завершается без выполнения опасных действий и без раскрытия чувствительных данных, а пользователю выдается извинение и запрос начать заново. Такой подход согласуется с принципом безопасности «отказы по умолчанию закрытыми»: системы должны быть спроектированы так, чтобы при сбое доступ прекращался【37†L29-L33】 (никаких неконтролируемых операций), что было подчеркнуто в Mod3.
> 
> ### Слой Domain (Core Logic)
> 
> Domain-слой содержит ядро бизнес-логики, связанной с выбором агрегатора и генерацией ссылки для покупки. Здесь реализованы основные **стратегии и правила**, сформированные исходя из анализа (Mod2/Mod3) и бест практик агрегаторов (Res1, MoonPay, Onramper и др.).
> 
> **Aggregator Selector** – компонент, отвечающий за выбор оптимального агрегатора под запрос пользователя. Когда пользователь вводит параметры (например, что хочет купить, на какую сумму, в какой валюте), Selector обращается к рейтинговой системе агрегаторов и выбирает наилучший вариант. Как предлагалось в Mod2, используется паттерн стратегии: каждый агрегатор представлен в системе как стратегия, зарегистрированная в **Strategy Registry** (реестр стратегий). Реестр загружается при старте приложения, регистрируя все доступные агрегаторы (например, MoonPay, Ramp, Mercuryo и т.д.) вместе с их особенностями. Добавление нового агрегатора сводится к добавлению его конфигурации и (при необходимости) класса стратегии, что упрощает масштабирование списка партнеров. Такой подход реализации плагинов/стратегий отражает предложения Mod3 по расширяемости системы (подключение новых on-ramp сервисов без рефакторинга ядра).
> 
> При выборе агрегатора учитываются несколько факторов через подсистему **Aggregator Scoring**. Эта подсистема рассчитывает оценку (скор) для каждого доступного агрегатора под заданный контекст: география пользователя, выбранная валюта, сумма, текущие лимиты и исторические показатели успеха/отказов. В основу положена идея агрегаторного скоринга из Res1: например, Res1 упоминал практику Onramper анализировать исторические данные успешности транзакций по странам и методам оплаты, чтобы выбрать агрегатор с наибольшим шансом успеха для данного пользователя【34†L1710-L1718】. Наша система реализует аналогичный **Decline Index** – индекс отказов/успехов, хранящий статистику: если определённый агрегатор часто отклоняет транзакции для пользователей с похожим профилем (например, из той же страны или для схожей суммы), его рейтинг для данного запроса будет снижен. Наоборот, агрегатор с исторически высоким процентом успешных проведений для таких условий получит повышенный скор. Таким образом, Domain-логика стремится максимизировать вероятность успешной покупки, персонализируя выбор под пользователя 【34†L1710-L1718】. Это напрямую повышает конверсию и соответствует лучшим практикам индустрии – по данным Onramper, интеллектуальный роутинг к правильному провайдеру способен повысить успешность онбординга на 30–60%【34†L1710-L1718】.
> 
> В расчет **скоринга** также входят статические **весовые коэффициенты**, заданные в конфигурации (см. Data-слой). Например, администратор может задать больший вес агрегатору с низкими комиссиями или более быстрой обработкой. Эти весовые схемы (Weights Scheme) применяются как множители к базовому рейтингу. Кроме того, принимаются во внимание **динамические лимиты** агрегаторов: Domain-логика проверяет, не превышена ли сумма запроса лимиты провайдера. Поддерживается механизм **Dynamic Limits** – актуализация лимитов на лету. Например, если агрегатор имеет дневной лимит объема транзакций или лимит на пользователя, бот может отслеживать исчерпание лимита. Данные о текущих доступных лимитах хранятся в Data-слое (например, в `LimitsStore`) и обновляются либо по событиям (отказ по причине лимита увеличит “индекс отказа” данного агрегатора), либо администратором. Таким образом, если агрегатор временно исчерпал свой лимит, Domain-слой заметит это и либо предложит пользователю меньшую сумму, либо переключится на другой агрегатор. Эта гибкость была заложена в предложениях Mod3 о **поддержке динамических лимитов**, позволяющей реагировать на изменения без перезагрузки приложения.
> 
> **Fail-Closed Guard (Domain)** – механизм безопасного завершения, интегрированный в Domain-слой. Он проверяет критические условия перед проведением пользователя к следующему шагу. Например, после выбора агрегатора проверяется, корректна ли сформированная deeplink-ссылка, доступны ли все необходимые параметры (API-ключи, поддерживается ли страна пользователем агрегатора, прошёл ли пользователь KYC, если нужно, и т.д.). Если какая-либо проверка не проходит, система не предпримет рискованных действий: выбор агрегатора отменяется и управление возвращается в Application-слой, который сообщит пользователю об ошибке. Таким образом, **любая ситуация неопределенности или потенциально небезопасное состояние приводят к “отказу” операции**. Это соответствует принципу fail-closed, упомянутому ранее, и обеспечивает соответствие высоким требованиям безопасности и комплаенса. В исследовании Ramp (Res2) отмечалось, что интеграция многих провайдеров несёт риски из-за разных стандартов безопасности у каждого【36†L158-L166】. Наш подход смягчает эти риски: мы интегрируем только проверенных агрегаторов (через Registry) и применяем строгие проверки. Если агрегатор не соответствует нашим требованиям или произошёл сбой, бот лучше откажет в операции, чем пропустит потенциально проблемную транзакцию. Как указывалось в Ramp, без должного уровня контроля комплаенса есть риск провести нелегальные или рискованные операции через платформу【36†L162-L169】. Наша архитектура закладывает эти контролы: каждый провайдер в реестре проходит валидацию схемы (см. Data-слой), а Domain-guard предотвращает выполнение операций вне допустимого диапазона.
> 
> **Deeplink Generator** – компонент, формирующий конечную платежную ссылку (deeplink) для выбранного агрегатора. После того, как Aggregator Selector определил оптимальный сервис, Deeplink Generator загружает шаблон ссылки из конфигурации (например, URL вида `https://provider.com/buy?apiKey=XXX&currency=ETH&amount={amount}&address={wallet}`) и подставляет динамические параметры: сумма, адрес кошелька пользователя для получения монет, выбранная фиат/крипто валюта, возможно, идентификатор пользователя для реферальной программы и пр. Шаблоны deeplink’ов заданы для каждого агрегатора в `aggregators.yml` и могут различаться (например, для MoonPay, Ramp и т.д. – свои URL и параметры). Генератор также использует секретные ключи API из конфигурации окружения (`.env`) при необходимости, чтобы подписать ссылку или добавить ключ партнёра. Результатом работы является **уникальная ссылка**, по нажатию на которую пользователь попадает либо на веб-виджет агрегатора, либо на страницу оплаты с уже заполненными параметрами покупки. Такой механизм соответствует концепции deeplink-шаблонов (отражено в Mod2): мы поддерживаем возможность быстро обновить шаблон в конфиге, если провайдер изменил формат URL, без изменений кода. Кроме того, использование deeplink ускоряет и упрощает путь пользователя: например, TrustWallet также применяет deeplink для направления пользователя к нужному провайдеру с заданными параметрами【28†L250-L259】【28†L268-L272】. Наш бот реализует аналогичный подход, но во внешнем интерфейсе Telegram: после всех шагов диалога пользователь получает готовую ссылку “Buy Crypto”, открывающую выбранный сервис с предзаполненными данными.
> 
> Стоит отметить, что Domain-слой реализует **регистрацию стратегий** (Strategy Registry) и связанные валидаторы не только при запуске, но и предоставляет интерфейсы для управления списком агрегаторов в будущем. Например, можно временно отключить стратегию агрегатора (если с ним проблемы) – для этого достаточно поменять флаг в конфигурации, и селектор больше не будет его выбирать (fail-closed для данного провайдера обеспечен на уровне конфигурации). Это помогает реагировать на инциденты, что соответствует рекомендациям Res2: в случае проблемного провайдера важно быстро его убрать, чтобы не страдала репутация платформы【36†L168-L170】. Благодаря Registry и централизованной проверке, система готова к оперативному включению/выключению агрегаторов.
> 
> ### Слой Data (Configs & Persistence)
> 
> Data-слой отвечает за хранение конфигураций, статических данных и (частично) динамических показателей, используемых Domain-логикой. Он включает:
> 
> **Aggregators Config (`config/aggregators.yml`)** – основной конфигурационный файл, описывающий интегрированные on-ramp сервисы (агрегаторы). В нём для каждого агрегатора заданы необходимые данные:
> - **Идентификатор и название** (для внутреннего использования и логирования).
> - **Параметры поддержки**: список стран или регионов, где сервис работает; поддерживаемые фиатные валюты и криптовалюты; минимальные и максимальные суммы транзакций; требования по KYC (например, какие лимиты без верификации и с полной верификацией).
> - **Лимиты**: базовые лимиты (суточные, месячные, на пользователя и т.д.). Некоторые из них могут быть помечены как динамические (dynamic), если ожидается их изменение.
> - **Fee/Commission**: комиссии агрегатора, которые можно учитывать при скоринге.
> - **Шаблон deeplink**: URL-шаблон для генерации ссылки, включая параметры запроса и плейсхолдеры.
> - **Прочие настройки**: например, необходимость подписывать запрос, формат даты, локализация (если агрегатор поддерживает передачу языка интерфейса).
> 
> Этот конфиг хранится в формате YAML для удобства редактирования. Поддержка локальных конфигов (как указано в условии) означает, что бот может читать настройки из файлов, поставляемых вместе с приложением (`config/*.yml`), и не зависит от хардкода. Это облегчает адаптацию под разные окружения и соответствует принципам 12-factor приложения (разделение кода и конфигурации). Например, в `.env` файл можно поместить API-ключи (MoonPay API Key, etc.), а в `aggregators.yml` – только именованные ссылки на эти ключи. Перед запуском в новом окружении достаточно предоставить свои файлы настроек. Такой дизайн предлагался в Mod3 для гибкости деплоя.
> 
> **Weights Scheme (`weights.yml`)** – отдельный YAML, задающий **весовые схемы** для агрегаторов. Здесь могут быть указаны глобальные веса приоритетов (например, агрегатор A – вес 1.0, агрегатор B – 0.8 по умолчанию). Также схема может содержать условия: например, для EU региона увеличивать вес агрегатора X (если он имеет локальный способ оплаты, что выгоднее), или снизить вес агрегатора Y для неподтверждённых пользователей (если он требует строгого KYC). Domain-слой (Scoring) при расчёте рейтинга обращается к этим данным. Разделение этого файла позволяет настраивать стратегию выбора без изменения кода – команда продукта может подправить веса и перезапустить бота, фактически изменив поведение ранжирования (предложено в Mod2/Mod3 для быстрой итерации стратегии). Наличие весовых коэффициентов также позволяет тонко сбалансировать работу с партнёрами – например, если по договорённости нужно направлять больше трафика на определённый агрегатор, это можно отразить весом.
> 
> **Dynamic Limits Store** – хранилище динамических данных о лимитах и статистике. Здесь могут использоваться разные подходы:
> - Если динамические лимиты управляются извне, бот может загружать обновления (например, администратор обновил YAML лимитов – бот перечитал файл, либо данные хранятся в Redis/БД и обновляются).
> - В более продвинутом варианте, бот сам отслеживает показатели: при каждом отказе из-за лимита или ошибке транзакции Domain сообщает Data-слою, и **индекс отказов** (Decline Index) обновляется для данного агрегатора/настройки. Эти счётчики могут храниться в памяти или в маленьком key-value хранилище. Например, `LimitsStore` может быть реализован на Redis: ключи – идентификаторы агрегаторов, значения – текущие остатки лимитов (обновляются после каждой успешной транзакции) и счётчики отказов.
> - Если агрегатор предоставляет API для статуса (например, сколько лимита осталось на сегодня), бот мог бы периодически опрашивать и обновлять эти значения.
> 
> Для начала, можно реализовать более простую модель: динамические лимиты в памяти, сбрасываемые при рестарте, или обновляемые вручную. Главное, архитектура уже предусматривает этот компонент, что отражает требование поддержки динамических лимитов (Mod3). В будущем этот компонент может эволюционировать до полноценной базы статистики. 
> 
> **Config Schema Validators** – модуль валидации конфигураций. При запуске приложения Data-слой проверяет, что `aggregators.yml`, `weights.yml` (а также `.env`) соответствуют ожидаемой схеме. Используются валидаторы схем: например, если `aggregators.yml` требует, чтобы у каждого агрегатора были поля `name`, `countries` (список) и `deeplink_template`, то валидатор пройдётся по всей структуре и выведет ошибку, если что-то не так (например, пропущен обязательный параметр или неверный тип данных). Аналогично, валидация весов: проверка, что сумма весов не нулевая, что указанные агрегаторы в weights.yml существуют в aggregators.yml и т.д. Этот механизм гарантирует **Fail Fast** поведение – бот не запустится, если конфигурация неправильна или небезопасна. Это было одним из предложений Mod3 для повышения надежности: ловить проблемы конфигурации на этапе деплоя, а не в рантайме.
> 
> Валидация схем тесно связана с fail-closed принципом: например, если в конфиге агрегатора Y не указан лимит, мы предполагаем консервативное значение по умолчанию или вообще отключаем его. Таким образом, лучше отключить или не выбрать агрегатор, чем допустить превышение лимита. Все эти проверки – часть стратегии **“secure by design”**. Согласно отраслевым обзорам, размещение агрегатора-посредника требует ещё более строгого контроля, иначе можно пропустить несоответствие регуляциям【36†L158-L166】. Наш Data-слой обеспечивает, что каждый подключенный провайдер явно сконфигурирован в соответствии с требованиями (что облегчает аудит) и что никакой «плохой» провайдер не проникнет незамеченным. В Ramp отмечали, что не все on-ramp провайдеры держат высокий стандарт комплаенса, и без контроля можно невольно вовлечь пользователей в рискованные транзакции【36†L159-L167】. Наша архитектура снижает этот риск через явную белую пропись конфигов и валидаторы.
> 
> Кроме конфигураций, Data-слой также управляет **.env (Environment)** переменными. Секретные ключи API, токен Telegram бота, ID чатов администраторов, URL-ы вебхуков (если используются) – всё это хранится в переменных окружения, подгружается при старте. Это выполнено согласно практикам безопасности: секреты не хардкожены в коде, их можно менять без пересборки. Поддержка `.env` была упомянута как требование (локальные конфиги), и она упростит настройку CI/CD: переменные окружения могут задаваться через интерфейс CI при деплое (см. ниже).
> 
> В итоге, Data-слой представляет собой **единый источник правды** для настроек системы. Компоненты Domain ничего не зашиты жестко – всё берётся из конфигов – что упрощает сопровождение (например, добавить нового агрегатора можно редактированием YAML + добавлением ключа API, без изменения кода). Это соответствует духу предложений Mod2/Mod3 и отражает практику, заметную у конкурентов: например, MoonPay и другие сервисы при встраивании обычно предоставляют конфигурационные параметры (API ключ, валюты и лимиты) в одном месте, чтобы интегратор мог легко их настроить.
> 
> ### Слой Infrastructure
> 
> Infrastructure-слой отвечает за внешние связи и эксплуатационные аспекты: интеграцию с Telegram, хранение данных FSM, развертывание и мониторинг. Этот слой обеспечивает, чтобы разработанная логика стабильно работала в продакшене и могла масштабироваться по мере роста (Roadmap S0–S6 имеет в виду рост функциональности и нагрузки).
> 
> **Telegram Bot API Integration** – модуль, через который бот общается с серверами Telegram. Здесь может использоваться готовая библиотека (например, Aiogram для Python, Telebot, Telegraf для Node.js, etc.), абстрагирующая HTTP API Telegram. Интеграция настроена либо на **long polling** (бот периодически запрашивает обновления) либо на **webhook** (Telegram пушит сообщения на наш сервер). Выбор способа зависит от инфраструктуры деплоя (для простоты возможно начать с polling). В архитектуре достаточно отметить, что Bot (App-слой) передаёт исходящие сообщения и читает входящие через этот компонент. Он гарантирует надежную доставку и обрабатывает низкоуровневые детали (например, повторные попытки при временных ошибках сети, обработку Rate Limit от Telegram и пр.). Принципы интеграции с Telegram были рассмотрены в Mod1, и выбрана безопасная модель: например, включены **fail-closed guards** на уровне API тоже – если Telegram вернул ошибку (например, Flood control, или недоступность), бот не будет бесконтрольно повторять действия, а переведёт пользователя в состояние ожидания/ошибки с уведомлением, чтобы избежать спама и соответствовать требованиям платформы.
> 
> **FSM State Storage** – внешнее хранилище состояния диалогов. Поскольку бот может иметь много параллельных пользователей и должен помнить контекст между сообщениями, FSM состояния (текущее состояние и временные данные пользователя) сохраняются вне процесса. На ранних этапах (S0) это может быть простое in-memory хранилище (словарь в коде) для одного инстанса бота. Однако целевая архитектура учитывает масштабирование (S1+): чтобы запустить несколько экземпляров бота (для нагрузки или отказоустойчивости) или перезапускать его без потери контекста, нужен внешний стор. Решение – использовать, например, Redis или базу данных. Redis удобен как быстрый key-value: при каждом переходе FSM сохраняем `{user_id: state, data}`. Если бот перезапущен или следующий запрос пришёл на другой инстанс, он загрузит состояние из Redis и продолжит диалог без нарушения. Это соответствует рекомендациям Mod3 (обеспечить хранение состояний вне приложения). Хранилище может также хранить краткосрочные данные – например, рассчитанный список подходящих агрегаторов перед финальным выбором, чтобы не пересчитывать при повторном запросе пользователя. Безопасность данных пользователя тоже учитывается: хранятся только минимальные данные (например, выбранная валюта, сумма) и на короткое время, личные данные (ФИО, документы) бот вообще не обрабатывает, делегируя KYC на сторону агрегатора. Таким образом, нагрузка на хранилище невелика, и оно в основном обеспечивает непрерывность UX. 
> 
> **CI/CD Pipeline** – непрерывная интеграция и деплой. Проект включает набор автоматизированных тестов (юнит-тесты Domain-логики: генерация ссылок, расчёт скоринга, тесты валидаторов; интеграционные тесты ключевых сценариев FSM; возможно, мок-тесты вызовов Telegram API). Эти тесты запускаются при каждом изменении в репозитории с помощью CI (например, GitHub Actions, GitLab CI или Jenkins – настроено в рамках Res2). В CI настроен **workflow**, который линтит код, прогоняет тесты и при их успешном прохождении может собирать docker-образ и деплоить на целевой сервер или платформу. Например, после мержа в `main` CI может задеплоить бота на staging/production (Continuous Deployment) – это ускоряет выход новых функций на прод и минимизирует человеческий фактор. Наличие тестов и CI было указано как обязательное требование (Mod3), что отражает ориентацию на качество и стабильность. Благодаря этому, любые изменения (в том числе обновление конфигов или добавление агрегатора) проходят проверку. Например, если разработчик добавил новый агрегатор в YAML, есть тест, который попытается сгенерировать deeplink и убедиться, что все необходимые поля присутствуют; если что-то не так – pipeline не позволит выкатить неверную конфигурацию. Этот процесс интегрирован с валидаторами Data-слоя: ошибки валидации также могут всплывать на этапе CI (например, скрипт, который читает YAML и валидирует схему, запускается в тестах).
> 
> Для Continuous Deployment настроены стратегии безопасного деплоя: например, **blue-green deployment** или **canary** – чтобы обновление бота не прервало сессии пользователей. Возможно, бот будет перезапускаться в ночное время или с небольшим downtime, что допустимо на ранних этапах (S0-S1). Но архитектура учитывает масштабирование: с внешним хранилищем состояния и статeless-сервисом, можно перезапускать бота без существенного влияния, а впоследствии даже реализовать zero-downtime деплой.
> 
> **Monitoring & Logging** – подсистема мониторинга. Для платформы, которая взаимодействует с финансовыми операциями, крайне важно иметь прозрачность работы и быстро реагировать на сбои. В боте реализован **логирование** всех ключевых событий: каждое обращение пользователя, выбор агрегатора, ошибки Domain-логики, ответы от Telegram API и пр. Логи отправляются либо в консоль (при локальном запуске), либо в централизованную систему (например, Elasticsearch/Kibana, Logstash, или более облачные решения). Также продумывается **метрика**: например, счетчики успешно выданных deeplink’ов, количество отказов по каждой причине (отказ агрегатора, неподдерживаемая страна, превышение лимита и т.п.), время ответа бота и т.д. Эти метрики могут собираться в Prometheus + Grafana для наблюдения. Мониторинг включает и **алерты**: при критических ошибках (например, ни один агрегатор не работает, или бот не отвечает) – отправляется уведомление разработчикам (по email или в специальный чат). Также возможно интегрировать **Sentry** или аналог для отслеживания исключений в коде с контекстом – это упростит отладку, если в продакшене случится непредвиденная ситуация.
> 
> Отдельно стоит реализовать мониторинг доступности самих агрегаторов: если, скажем, API MoonPay не отвечает, бот может ловить таймаут при генерации deeplink (или узнает о недоступности из ошибки). Такой случай логируется, и Fail-Closed Guard не даст направить пользователя в неработающий сервис. Но команды DevOps через мониторинг увидят, что, например, агрегатор MoonPay 5 раз подряд не выдал ответа – можно временно отключить его (поставив флаг в конфиге) и узнать у партнёра о проблеме. Таким образом, мониторинг замыкает цикл feedback: **данные, собранные мониторингом, могут использоваться для улучшения правил Domain**. Это соответствует подходу MoonPay, который активно использует анализ метрик и фидбек для улучшения продукта【32†L337-L345】. У нас, например, на основе логов можно скорректировать весовые коэффициенты или пороги лимитов (итерация S5-S6 Roadmap).
> 
> Наконец, инфраструктура предусматривает **безопасность и комплаенс** на уровне развёртывания: доступ к конфигурациям ограничен (секреты в .env шифруются или хранятся в защищённом хранилище CI), канал бота с агрегаторами защищён (SSL для webhook), а сам сервер бота находится под мониторингом на предмет аномалий. Эти моменты частично выходят за рамки схемы, но соответствуют индустриальным стандартам, озвученным в Res2 (например, MoonPay имеет ISO-27001 и сложную систему противодействия fraude【32†L221-L230】【32†L238-L242】; наш проект на порядок меньше, но перенимает принцип “безопасность прежде всего”).
> 
> ### Соответствие лучшим практикам и целям Roadmap
> 
> Предложенная архитектура напрямую поддерживает целевой Roadmap S0–S6, закладывая фундамент для развития:
> - **S0**: Базовый функционал – реализуется описанной архитектурой, уже поддерживающей несколько агрегаторов, мультиязычность, базовые лимиты.
> - **S1-S2**: Масштабирование пользователей – благодаря FSM State Storage и stateless-логике, можно горизонтально масштабировать бота.
> - **S3**: Добавление новых агрегаторов – упрощено через Strategy Registry и конфиги.
> - **S4**: Улучшение UX – поддерживается за счет локализации, дружелюбных ошибок, можно добавлять новые сценарии в FSM без переписывания ядра.
> - **S5**: Продвинутая аналитика и оптимизация – мониторинг и Decline Index дают данные для улучшения скоринга (например, машинное обучение в будущем на основе собранных данных о отказах/успехах).
> - **S6**: Строгий комплаенс и надежность – архитектура с fail-closed, валидаторами, тестами и CI уже нацелена на высокую надежность и соответствует идее “не навреди”: лучше отказать, чем провести некорректную операцию.
> 
> Мы также учли инсайты внешних провайдеров:
> - MoonPay акцентирует внимание на снижении отказов транзакций (например, предупреждая пользователей о банках, которые вероятно отклонят оплату)【32†L253-L258】. В нашем дизайне Decline Index и динамические лимиты выполняют схожую роль – предупреждают систему о потенциальных отказах и обходят их, направляя пользователя к более надёжному варианту.
> - Ramp Network указал на проблемы агрегаторов с поддержкой пользователей【36†L171-L174】 и качеством интерфейса. Наш бот смягчает эти проблемы: интерфейс Telegram сам по себе унифицирован и простой, а мы стараемся давать максимум информации пользователю на его языке, улучшая UX. Также мы включаем в план наличие FAQ внутри бота или быстрых подсказок, чтобы пользователь не оставался один на один с ошибкой.
> - Лучшие практики безопасности (“deny by default”, многоуровневые проверки) воплощены через fail-closed guards и валидацию – это критично, когда имеешь дело сразу с несколькими финансовыми сервисами.
> - Опыт агрегаторов (Onramper) показал, что умный роутинг повышает конверсию【34†L1710-L1718】 – поэтому наша Domain-логика с самого начала делает упор на агрегаторный скоринг, вместо простого случайного или циклического выбора.
> 
> В совокупности, архитектура **To-Be** предоставляет гибкую, безопасную и расширяемую платформу Telegram on-ramp бота. Она основана на исходных предложениях (Mod1/2/3) – таких как использование FSM, разделение на слои, конфигурируемость – и на учёте исследований (Res1/2) о рынке on-ramp (включая практики MoonPay, Ramp и агрегаторов). Этот фундамент позволит в дальнейших этапах Roadmap быстро развивать функциональность, оставаясь уверенными в надежности и удобстве системы для конечных пользователей. 
> 
> **Источники:**
> 
> - Aiogram FSM usage – Importance of FSM for step-by-step bot workflows【38†L475-L483】  
> - Onramper smart routing increases success rates by 30–60%【34†L1710-L1718】  
> - Ramp Network on compliance and risk of aggregators【36†L158-L166】【36†L162-L169】  
> - Ramp Network on lack of support in aggregators【36†L171-L174】  
> - MoonPay proactive approach to high decline rates (flagging likely declines)【32†L253-L258】  
> - MoonPay user-centric design and multi-language support for global reach【32†L315-L323】  
> - Security by design – fail-secure (fail-closed) principle【37†L29-L33】

### Secondary findings
- None

## Что менять в репо
- bot/
- core/
- docs/compliance/
- integrations/
- static/
- templates/
- tests/

## DoD
- HTTP 200 from integration endpoints
- UX review accepted
- manual review by compliance officer
- pytest -q passes
- vulnerability scan clean

## Risks
- API rate limits
- KYC limitations
- data breaches
- flaky tests
- misconfigured auth
- regulatory changes
- third-party downtime
